# Import Blueprint to create a modular set of routes
# Import abort to stop execution and return error responses
# Import make_response to create custom HTTP responses
# Import request to access incoming HTTP request data
from flask import Blueprint, abort, make_response, request

# Import the Book model class to create new book instances
from app.models.book import Book

# Import db to interact with the database (add, commit, query, etc.)
from ..db import db

# Old import when using in-memory list (now using database instead)
# from app.models.book import books

# Create a Blueprint named "books" with URL prefix "/books"
# All routes in this blueprint will start with /books
books_bp = Blueprint("books_dp", __name__, url_prefix="/books")

# Decorator: Register this function to handle POST requests to /books
@books_bp.post("")
def create_book():
    # Get the JSON data from the incoming request body
    request_body = request.get_json()
    
    # Extract the "title" value from the request JSON
    title = request_body["title"]
    
    # Extract the "description" value from the request JSON
    description = request_body["description"]

    # Create a new Book object with the title and description
    # The id will be auto-generated by the database
    new_book = Book(title=title, description=description)
    
    # Add the new book to the database session (staging area)
    db.session.add(new_book)
    
    # Commit the changes to save the book to the database permanently
    db.session.commit()

    # Create a response dictionary with the new book's data
    response = {
        "id": new_book.id,              # Auto-generated database ID
        "title": new_book.title,        # The book's title
        "description": new_book.description,  # The book's description
    }

    # Return the response with status code 201 (Created)
    return response, 201

# Decorator: Register this function to handle GET requests to /books
@books_bp.get("")
def get_all_books():
    # Build a SQL query to select all Book records from the database
    # order_by(Book.id) sorts them by ID in ascending order (1, 2, 3...)
    query = db.select(Book).order_by(Book.id)
    
    # Execute the query and get the results as Book objects
    # scalars() returns the actual Book objects (not raw database rows)
    books = db.session.scalars(query)
    # We could also write the line above as:
    # books = db.session.execute(query).scalars()

    # Create an empty list to hold the book data in dictionary format
    books_response = []
    
    # Loop through each Book object returned from the database
    for book in books:
        # Convert each Book object into a dictionary and add it to the list
        books_response.append(
            {
                "id": book.id,              # The book's database ID
                "title": book.title,        # The book's title
                "description": book.description  # The book's description
            }
        )
    
    # Return the list of book dictionaries as JSON (Flask auto-converts)
    # Status code defaults to 200 (OK) if not specified
    return books_response


# @books_bp.get("")
# def get_all_books():
#     books_response = []
#     for book in books:
#         books_response.append(
#             {
#                 "id": book.id,
#                 "title": book.title,
#                 "description": book.description
#             }
#         )
#     return {"books": books_response}

# @books_bp.get("/<book_id>")
# def get_one_book(book_id):
#     book = validate_book(book_id)

#     return {
#         "id": book.id,
#         "title": book.title,
#         "description": book.description
#     }

# def validate_book(book_id):
#     # PART 1: Check if book_id is a valid number
#     try:
#         book_id = int(book_id)
#     except ValueError:
#         response = {"message": f"book {book_id} invalid"}
#         abort(make_response(response, 400))  # ← abort #1 is INSIDE except
#         # If this abort runs, function STOPS here
    
#     # PART 2: Search for the book (only runs if Part 1 succeeded)
#     for book in books:
#         if book.id == book_id:
#             return book  # Found it! Return and exit
    
#     # PART 3: If we reach here, book wasn't found
#     response = {"message": f"book {book_id} not found"}
#     abort(make_response(response, 404))  # ← abort #2 is OUTSIDE, at the end
